#指定路径
.libPaths()
#常用的bioconductor镜像
#https://mirrors.tuna.tsinghua.edu.cn/bioconductor
options(BioC_mirror="https://mirrors.tuna.tsinghua.edu.cn/bioconductor/")
BiocManager::install("clusterProfiler")

#去除重复项目
unique

#构建矩阵
C <- data.frame(id1=c(1:5),id2=c(11:15))
#将稀疏矩阵转化为矩阵（不用导入导出csv了）
a <- as(sce.integrated4_HC@assays$RNA@counts, "matrix")

#筛选，查找个数
res_padj <- res_padj[which(abs(res_padj$log2FoldChange) >= 1), ]
nrow(c[which(c$DEGs == 'down'), ])
#去除所有为0的行
av.exp_2 <- av.exp_2[which(rowSums(av.exp_2==0)==0),]
#去除名叫cell_from_q.value和cell_to_q.value的列
res_3<-res_2[,-grep("cell_from_q.value|cell_to_q.value",colnames(res_2))]

## 升序
iris[order(iris$Sepal.Width), ]
## 降序
iris[order(iris$Sepal.Width, decreasing= T), ]
##求并集、交集
setdiff(x=1:4, y=2:3)
intersect(x=c("abc", "bcd"), y = c("abc", 12, "apple"))
##match的逻辑：match的后置
BD_unique <- na.omit(BD_rp[match(support$support,BD_rp$support),,drop=F])


#选取前几行
data[1:5, ]

#保存对象为Rdata
save(sce.integrated3, file = "T cell-test/Treg_PBMC.RData")
#保存csv文件
write.csv(pbmc.markers,file="T cell-test/pbmc.markers_Treg.csv")
a <- read.csv("BD NETs/DEseq2-DE_genes.csv", header = TRUE, sep = ",",quote="\"", dec=".",
              fill = TRUE,comment.char="",row.names = 1)

#读写txt 
write.table(count_norm_BD, file="T cell-test/count_norm_BD.txt")
data<-read.table(data_file,header = T,sep ="\t",stringsAsFactors=FALSE,row.names = 1)

#设置函数
yuxin <- function(x){}
#最后一行将是yuxin(x)的结果

#拼接的逻辑
paste(t,"BD",sep="_")

DEG_compare_yuxin <- function(test1){
  test1[which(test1$avg_logFC >= 0 & test1$p_val_adj <= 0.05 ),'DEGs'] <- 'up'
  test1[which(test1$avg_logFC <= 0 & test1$p_val_adj <= 0.05),'DEGs'] <- 'down'
  test.list=list() #首先需要构建一个list
  for (cell in unique(test1$cell)) {
    up <- nrow(test1[which(test1$DEGs == "up" & test1$cell == cell),])
    down <- nrow(test1[which(test1$DEGs == "down" & test1$cell == cell),])
    t <-data.frame(cell = c(cell, cell), DEGs=c(up,down),label=c("up","down"),label_2=c(0,1)) #至此，构建了一个矩阵t。注意t的格式，是为了画图
    test.list[[cell]]=t #每一个t作为list中的一个元素，命名为cell
  }
  testData=do.call(rbind,test.list) #仅仅是为了把list里面的元素合并起来
  p <- ggplot(testData, aes(x = cell, y = DEGs, fill=reorder(label, label_2)))+
    geom_bar(stat = "identity",position="dodge") #position=dodge是并列，否则就是同列；reorder的目的是固定顺序
}


#
substitute() #变量名称转化为字符串

#分列，df是矩阵，b是要分的列，bc是新名字
df<-separate(df,b,into = c("b","c"),sep = "_") 

##数值转化的问题
typeof(data1) #查看类型
plot.data$pvalue <- as.numeric(as.character(plot.data$pvalue)) #将factor转化成number；注意必须先转化成character，再转化

